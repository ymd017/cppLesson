■Windows API

APIは異なる2者の間で、やり取りをするためのに用意された関数や仕組み

情報は関数で取得するか、
あるいは構造体を用意し、関数で構造体に情報をセットして使用する。
構造体はただのデータの入れ物
API関数を使って取得して、メンバに格納している

全てのデータが構造体に格納してから使うわけではなく、
関数を呼び出せば取得できるものもある。
構造体として他のデータとセットにするかどうかの違い。
他のデータを追加する予定なら、構造体になっている。

Windows APIがクラスではなく、構造体を使っているのはWindows APIがC言語ベースで作られているから

GetLastInputInfo()自体が構造体のメンバを書き換える関数

構造体型に加え、型はDWORD、LPCTSTR(Windows API専用の文字列でUnidoce)など独自の型がある。

DWORD
Windows APIの整数型で、符号なし。確実に 32bit（4バイト）を保証する

構造体のバージョンを知るために、cbSizeというデータサイズをメンバに持っていることがある。
sizeofで構造体のサイズを測る。

構造体自体の情報を書き換える場合は構造体のアドレスを渡す。
値コピーの時は構造体の値を渡す。

構造体の初期化は = {}
構造体のデフォルトはpublic

プログラム（プロセス）が 直接 OS の内部リソース（メモリ・プロセス・ファイル・ウィンドウなど）にアクセスすることはできない
ハンドルを取得して、ハンドルに指示を書いてOS(の中でもカーネル？)に操作してもらう
そもそもハンドルをもらえないこともある。

プロセスとは、実行中でメモリに展開されているのプログラム。
カーネルが管理するオブジェクト。
操作するにはハンドルが必要。
自分自身のハンドルは疑似ハンドルと言い、GetCurrentProcess()で取得できる。閉じる必要なし。
他のプロセスのハンドルはOpenProcess()で取得する。CloseHandle()で閉じる必要あり。

トークンとは各プロセスに紐づけられている権限。
カーネルが管理するオブジェクト。
操作するにはハンドルが必要。
トークンのハンドルはOpenProcessToken()を使う。
トークンのハンドルは最後に閉じる必要がある。

GetLastInputInfo()はキーボードやマウスなどの最後の入力のティックカウント

SetSuspendState()でスリープ状態にするには、プロセスがPCをスリープ状態にする特権が必要。
プロセスのトークンにアクセスするので、まずはプロセスにアクセスできるようにGetCurrentProcessで疑似ハンドルを取得し、その後プロセスのトークンにアクセスするためにOpenProcessTokenでハンドルを取得する。そして最後にAdjustTokenPrivileges()を使ってスリープ状態にする特権を有効にする。
（SetSuspendState()はPCを休止状態やスリープ状態にできるが、PC電源関連の操作は特権が必要で、
プロセスの権限（トークン）の中でも特権の"SE_SHUTDOWN_NAME"を
AdjustTokenPrivileges()で有効にしてから使う必要がある。）

SetSuspendState()はWindows の powrprof.dllに格納されている。
user32.dllは自動でリンクされるが、powrprof.dllは自動でリンクしないので自分でリンクする。
リンカに教えるためのファイル（インポートライブラリ）のpowrprof.libで場所を教える必要がある。
#pragma comment(lib, "powrprof.lib")

Windows APIはUnicodeを使うのが基本。ANSI/Unicodeどちらの環境であってもTEXT()を使えば文字列を扱えるようになる。
Windows APIはデフォルトでUnicodeだが、Unicode定義がない場合はANSIになってしまう
MessageBox() の引数のうち、2個目・3個目の LPCTSTR 型の文字列を TEXT() で囲む理由はLPCTSTRはUnicodeだから。


■マルチスレッド

メイン処理とは別の流れで処理をする。
メイン処理がその処理を待たずに進むようになる。
並列処理ができるようになる、応答性があがる

スレッドはオブジェクトであり、std::thread th1(スレッドで実行する関数)で初期化する。

メイン処理がマルチスレッドを待つようにするにはth1.join()を使う
メイン処理と完全に独立させるにはth1.detach()を使う。

スレッドを作ると並行処理が可能になる、処理速度が向上する


■C++ の基本

std::this_thread::sleep_for()は実行を指定時間止めて、CPUコアを他にゆずる。

Sleep()とstd::this_thread::sleep_for()の違いは時間の単位を指定できるか、どのOSでも使用できるかが異なる。

Sleep()は引数で渡したミリ秒数実行を停止し、他のPCにCPUコアを貸す
ポーリング処理、数秒間停止、何秒間隔で繰り返すのに使う

Sleep(0)は他にスレッドがあればそちらを優先させる。なければ今すぐ実行する

std::chronoを使うと、分、秒、ミリ秒などの時間で統一して指定できるし、わかりやすい

構造体の初期化はデータを直接入れるような、{}の形。
Rectangle rectangle = {10, 20};
クラスの初期化はコンストラクタなので、関数のような形。
Rectangle rectangle(10, 20);
違いはアクセス修飾子のデフォルトが異なるだけ。
実質的には同じだが、使われ方が区別されている
【構造体】
データの塊として使うだけ、シンプルに扱いたいとき
ゲームプログラミング（座標や色のデータ）や、API のデータ構造
【クラス】
オブジェクト指向で、カプセル化、継承、ポリモーフィズムをやりたいとき。
メンバ関数を持たせて、データと処理を紐づけたいとき



■ツールを作るとき
何をしなければいけなくて、情報的に何がいるのかを考える

公式ドキュメントの読み方
とりあえず、何をする関数なのかをざっくり理解して、何のために使うのかを理解していく。
関数単体だけじゃなく、周辺情報もざっくり把握したほうが近道




